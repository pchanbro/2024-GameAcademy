#include <iostream>

using namespace std;

class Game
{
public:
	void Init() {}
	void Draw() {}
	void Update() 
	{
		// Input을 관리하는 객체 (클래스)
		// Input에서 마우스 클릭이라는 일이 생기면

		// 마인 생성
		// scv 미네랄 캐기 등
	}
	void Release() {}
};

void main()
{
	// 2. 클래스 
	// 객체 지향 프로그래밍
	
	// 그동안 콘솔에서 해온 프로그래밍 방식은
	// 절차 지향 프로그래밍 이다.
	
	// 절차 지향 프로그래밍은
	// 함수들로 구성되어 있어
	// 위에서 아래로. 코드를 읽기만 하면 된다

	// 객체 지향 프로그래밍은
	// 객체를 여러 개 만들어서 
	// 객체끼리 알아서 상호작용 되도록 만드는 것이
	// 객체지향 프로그래밍

	// class 많이 쓰면 객체지향 프로그래밍이다.

	// 오늘의 이론은
	// 이상향에 가까운 이야기들
	// 클래스 5대 원칙
	// 디자인 패턴

	/*Game* game = new Game();
	game->Init();
	while (true)
	{
		game->Draw();
		game->Update();
	}

	game->Release();*/

	// 객체지향 프로그램은 왜 쓰는가?

	// 절차 지향 프로그래밍
	// 단점 :
	//	- 기획 단계에서 뭔가 바뀌면, 수정하기가 어렵다.
	//	- 이미 서로서로를 너무 의존하고 있기 때문에
	// (위에서 아래로 흐르고 있는데, 윗물에서 수정이 일어나면 아래를 모두 바꿔줘야 한다.)
	// - 유지보수성이 안좋다.
	// - 생산성도 안좋다.
	// (협업을 하게되면, 모두가 위에서 아래로 코드를 짠다.)
	// (파일 하나에서 위에서 아래로 짜게되먄)
	// A 프로그래머가 5Line ~ 15Line 수정했다.
	// B 프로그래머가 30Line ~ 45Line 수정했다.
	// 이 때 A프로그래머가 변수명을 수정하면?
	// 머지할 때 문제가 많다.
	// 그래서 파일 분할을 최대한 많이한다. (회사에서는)

	// 그래서 객체지향 프로그래밍을 하게 된다.

	// 객체 지향 프로그래밍
	// 장점 : 
	//	- 유지보수성이 좋다.
	//	- 협업에 좋다.

	// 단점 :
	//	- 코드 레벨이 올라간다.
	//	- 실행 속도가 느리다. (이론상 파일 하나로 실행하는게 컴퓨터 입장에서 빠르다)
	// (근데 실행 속도는 크게 신경쓰지 않아도 좋다)

	// 코드로 최적화하는것보다
	// 3D모델, 2D텍스처에서 조금 이득보는게 훨씬 좋다.

}