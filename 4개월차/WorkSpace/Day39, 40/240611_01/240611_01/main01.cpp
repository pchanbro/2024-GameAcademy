#include <iostream>
using namespace std;

void main()
{
	// 저번시간까지 배운 것
	// - 우선순위큐

	// ==> 가장 우선도가 높은 노드를 먼저 꺼내게 하는 자료구조
	// 우선순위큐는 알고리즘에 쓰임
	//  - 데이터를 넣을 때 시간복잡도 : O(logN)
	//  - 데이터를 뺄 때 시간복잡도 : O(logN)
	//  - 다음 데이터가 무엇인지 확인하는데 드는 시간복잡도 : O(1)

	// 콘솔로 넘어온 이유 :
	//   길찾기 알고리즘을 만들기 위해서 콘솔에서 그 기반을 다지기 위함




	// 코딩테스트
	//  적게나오면 3문제, 많이나오면 5문제

	// 5문제짜리 테스트 기준

	// 1번 문제 : 문자열 자르기 / 문자열 조합하기 / 문자열 가지고노는 문제
	//		  아니면 완전 기초적인 문제


	// 2번 문제 : 그리디 알고리즘(알고리즘 이름을 몰라도 대충 프로그래밍 기본기만 있으면 풀 수 있는 알고리즘)

	//  5000원짜리 지폐 몇장이고 1000원 지폐 몇장있고, 100원짜리 동전 몇개 있고
	//    8600원을 내려면 뭐 최소 동전 지폐 합산 몇개를 내야하는가?


	// 3번 문제 : 그래프 자료구조를 사용한 알고리즘 (노력으로 극복가능한 파트)
	
	// 4번 문제 : 그래프 자료구조를 사용한 알고리즘 or 수열 문제

	// 5번 문제 : 수열 문제 (Dynamic programming) (기본을 배우고 운에 따르는 파트)


	// 수열 문제 => 그날 문제보고 풀 수 있겠다 없겠다 구분이 가능, 운에 맞겨야 함


	// 오늘 배울 내용은 그래프 자료구조와 밀접한 관련이 있다


	// 그래프 자료구조
	// 
	// 그래프란??
	//   - 정점과 간선으로 이루어진 자료구조
	//   - Vertex, Edge로 이루어진 자료구조

	// - 길찾기 알고리즘에 많이 사용된다.


	// 그래프 자료구조를 사용한 알고리즘 ( PPT 확인)
	// DFS, BFS

	// 길찾기 알고리즘
	// DFS, BFS 나오면 길찾기 알고리즘이라고 생각나면 된다.


	// DFS (깊이 위주 탐색) (Stack 자료구초, 후입선출)
	// 출발점으로부터 갈 수 있는 모든 정점을 구한다.
	// 정점 하나를 정하면, 그 점의 끝을 볼때까지 파고든다,
	// 인덱스가 작은것부터 하나씩 끝까지 파고든다.
	// 그 후에 갈래길 있는곳으로 돌아와 그 끝은 확인하는걸 반복해서 전부다 돌때까지 파고든다.
	// 그렇게 파고들 때 마다 점들을 추가해준다.
	// 끝을 봤으면, 하나씩 뒤로가서 다시 체크한다.


	// BFS (넓이 위주 탐색) (Queue 자료구조, 선입선출)
	// 출발점에서 갈 수 있는 모든 점들을 추가한다
	// 그 중 인덱스가 작은 점에서 연결되는 모든 점들을 추가한다
	// 그 중 인덱스가 큰 점에서 연결되는 모든 점들을 추가한다.
	// 피라미드 구조 느낌으로 그렇게 한층씩 인덱스가 작은 점에서 부터 인덱스가 큰 점까지 순서대로 연결되어 있는 점들을 다 추가한다.


	// DFS, BFS
	// 실제 프로그래머스 문제 통해서 수업 진행
}

void Comment2()
{
	// 코딩테스트 문제를 볼 때
	// 그림은 -> 1번예제는 샘플로 왜 이렇게 돼서, 결과값이 어떻다 를 보여줄때 참고용, 오래보지 마라

	// 우리가 파악할 내용
	//  - 1. 입력값이 뭐가 들어오는건지?
	//  - 2. 어떤걸 봔환시켜야 하는지?

	// 그러니 그림이 아닌 입출력 예를 파악해야한다.
	
	// 한문제에 50분은 주어지기 때문에 
	// 문제를 이해하는데 10분 사용해도 된다.

	// 일단 문제를 주석으로 옮겨라

	// 컴퓨터의 개수 n
	// 연결에 대한 정보가 담긴 2차원 배열 computers
	// 네트워크의 개수를 return

	// DFS, BFS
	// 그림이 뭔가 길찾기스럽다 << 이러면 대부분 DFS, BFS문제일 확률이 90프로가 넘는다.

	// 수학문제처럼
	// 풀이방식이 1개는 아니다.

	// DFS, BFS 둘 다 풀 수 있다.

	// 근데 가끔 둘 중 하나로만 풀 수 있는것들이 있다.
	
	// DFS 단점
	// - 최소값이랑은 거리가 멀다.

	// BFS 단점
	// - 메모리 낭비(메모리가 부족할 수 있다.) (극단적인 상황)

	// 문제에서 (최소) (최대한 빨리) 라는 단어가 나오는 길찾기 문제
	//  ==> BFS 를 써라


}