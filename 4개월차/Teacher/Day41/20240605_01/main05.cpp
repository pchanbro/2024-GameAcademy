#include <iostream>


using namespace std;

void main()
{
	// 길찾기 알고리즘
	// 다익스트라보다 더 좋은게 없을거 같은데?
	// BFS 만큼 깔끔하게 길찾는 방법이 없을줄알았는데 (간선의 비용이 다른경우 문제가 생김)
	// 간선에 비용을 추가해서 더 효율적인 길을 찾는 Dijikstra 로직이 만들어짐. 
	//	( 원하는건 end 포인트에 대한 길찾기인데 뭔가 효율적이지 않음 )
	// 
	// dijikstra 를 조금 변형해서
	// astar 알고리즘

	// 비용계산을 조금 다르게합니다.
	// queue에 넣을때
	// 다익스트라 같은 경우 -> G [내 현재까지 온 비용 + 거기까지 가는 비용]
	// astar 경우 -> G [내 현재까지 온 비용 + 거기까지 가는 비용] + H (이동할 좌표부터 해당 내용까지 가는 예상 기댓값)


	// 우선 순위 큐에 대해 알아야하고
	// DFS, BFS에 대해 알아야하고
	// BFS -> 다익스트라로 변형하는 과정
	// 다익스트라 -> 에이스타로 변형하는 과정

}


//숙제 2개

// 1. 콘솔에서 Astar로 미로 길찾기 (BFS랑 길이 달라지진 않습니다.)
// 2. Windows API에서 BFS나, Astar 사용해서 타일 클릭하면 플레이어가 해당 타일로 이동하는 로직 만들기




// 길찾기 알고리즘 (A*)

// 길찾기 알고리즘 
// 가장 보편화되어있는 알고리즘 
// DFS, BFS
//  => 그래프 자료구조  
//     (정점, 간선)
// 공통점 : A정점에서 ?정점을 갈수있는지?

// DFS, BFS 차이점
//  DFS => 깊이 탐색 알고리즘으로, stack을 통해서
//         하나의 정점을 선택했으면, 
//			그 정점에서 더이상 갈수없는 지점까지 먼저탐색

//  BFS => 넓이 탐색 알고리즘으로, queue를 통해서
//			갈수있는 정점들을 depth가 같아지는 선에서 점점 넓혀감
//	        "최대한 빨리" 알고리즘

// DFS, BFS => 그래서 특정 정점에서 ?정점을 갈수있냐 없냐.
//   문제가 발생함.
// 그럼 A->D 노드를 가는데, 사실은
//   A->C->D 가는게 제일 빠른데
//   A->E->B->D 이렇게 간다고 길을 알려줌.
// 왜냐면 DFS, BFS는 비용은 체크안하고 단순하게 갈수있냐 없냐만 체크함.

// 다익스트라 (dijikstra) 알고리즘  (사람 이름)
//  간선에 비용을 추가시켜서,
//  BFS로직을 적용
//  "최대한 빨리" 각 정점을 지나는 방법을 탐색하는 알고리즘
//  BFS (queue => priority_queue 로 수정)

//   문제가 발생.
//  나는 단순히  직선방향으로만 탐색해도 금방찾을것같은 목적지인데
//  모든 경우의 수를 계산하려함.
//   => 느려집니다.

//  ○○○○○○○○○
//  ○○○○○○○○○
//  ○○○○●○○○○   
//  ○○○○○○○○○
//  ○○○○○○○○★


//  Astar => 목적지가 있는 경우에 최적의 길찾기를 계산
//  (queue => priority_queue 로 수정)
//  priority_queue 넣는 비용을
//  다익스트라 => 처음 위치에서 해당 위치로 가는데 드는 비용 (G)
//  에이스타 => 처음 위치에서 해당 위치로 가는데 드는 비용 (G) 
//				+ 해당위치에서 목적지까지 가는데 드는 예상 비용 (H)



// 자료구조, 알고리즘 (코테, 면접)
// - linked_list, vector, BinaryTree
// - map
// - queue, stack
// - priority_queue

// 알고리즘
//  - BinarySearch
//  - DFS, BFS, dijikstra, astar

