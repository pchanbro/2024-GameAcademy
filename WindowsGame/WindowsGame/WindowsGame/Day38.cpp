#include "pch.h"

void Comment1()
{
	// 오늘 수업 내용

	// 1. 숙제 풀이
	//  - 타일 이동
	//

	// 2. 길찾기 알고리즘 (많이 어렵습니다)
	//  - 많은 알고리즘을 배워야 한다.

	// - 길찾기 알고리즘을 확실하게 이해하기 위해서(신입 레벨에서 알기는 사실 어려운데 면접에서 물어보면 답해야함)
	//  - 다른 부수적인 알고리즘을 같이 배워야한다.
	//  - 왜 이렇게 발전되었는지도
	
	//   - 이거 면접에서 물어봤는데 답 못하면 많이 힘들어진다.

	//  - 당분간 콘솔 프로젝트 진행할 것

	//  - 유일하게 코테랑 현업 둘 모두와 관련이 있는 알고리즘
}

void Coment2()
{
	// 타일이동

	//  - 구현하기 전에 노트(Best), 주석으로 생각을 정리하고 가는게 좋다.

	// <타일맵 게임>
	// 이동 시퀀스

	// 플레이어 입장 (컨트롤러 입장)
	//  - 키를 누르면 
	//  - 움직인다. (한 칸을 움직인다.)

	// Console 프로젝트면 저렇게 해도 큰 문제가 없다.
	// 자연스러운 이동이 없기 때문에 순간이동해도 크게 문제가 없다.

	// Windows API부터는 자연스러운 이동을 위해
	// Update 개념이 필요

	// Controller
	//  - 키를 누르면 
	//  - DestPos을 정해준다. (DestinationPosition, 도착지점 포지션) (컨트롤러 입장)
	// 
	//  Character Update
	//  - DestPos이 될 때까지 해당 방향으로 계속 이동한다. (캐릭터 입장)



	// <타일맵 게임> - cellPos를 사용하면 추후 유용함.
	
	// TilemapActor - 타일맵자체를 말하는 액터 (아래의 ITilemapActor 와 헷갈리지 말것)
	
	// interface - C++ 에서의 interface는 상속과 같음
	//  - 함수만 제공하겠다.
	//  - 이거를 상속받은 객체에
	// 인터페이스는 함수만 작성. 순수 가상함수로만 구성한다.

	// 타일맵 게임에 등장하는 Actor한테 주는 함수들 - ITilemapActor(사실 위에 TilemapActor가 존재해서 이런 이름은 좋지 않다.)

	
	// Vector2 같은 애매한 값으로 들고있는게 아니라.
	// CellPos 같은 확실한 타일값을 알려주는게
	// 나중에 더 유용하다. (서버, 버그수정 등등)



	// 충돌체크.
	//  - 충돌체크 이후 움직이는 로직의 방식

	// 2가지 방법
	
	// 1. 움직인 이후에
	//   - 뭔가에 걸리면, 돌아온다.

	// 2. 움직이기 전에 
	//   - 거기가 갈 수 있는 곳인지 체크하고 움직인다.
}

void Comment3()
{
	// ppt 활용

	//자료구조(시간복잡도)

	// 길찾기 알고리즘

	//  - 이진트리 Binary Tree

	// 장점 : 찾는게 빠르다. O(logN) N개의 노드가 있을 때 특정 노드를 찾는데 걸리는 시간
	// 단점 : 한쪽으로 기형적으로 커질 수 있다.

	// 이 단점을 보완하는 자료구조가 필요하다.


	
	// RedBlack Tree(Heap Tree의 일부)

	// 장점 : Binary Tree의 단점을 보완한 버전 ( 항상 균일하게 분포되어 있다.)



	// Heap Tree

	// 장점 : Binary Tree의 단점을 보완한 버전이라 할 수 있는데 Binary Tree와는 많이 다름



	// 우선순위 큐 (priority queue) (생긴건 트리구조인데 트리는 아님) 
	// (이렇게 분배가 잘되어있는 트리는 배열로 표현할 수 있다 -> 배열로 선언하면 시간복잡도 측면에서 유리하기 때문에 이 경우엔 배열로 쓴다.)
	
	// 값이 큰거부터 항상 나오게끔 세팅해주는 자료구조
	// 보통 큐는 선입선출인데, 이 우선순위큐는 선입 선출이 아닌, 말 그대로 우선순위대로 세팅해서 나오게끔 해주는 자료구조
	// 우선 순위 큐는 보통 단독 자료구조로는 안쓰이고 알고리즘에 포함되어서 쓰이는 경우가 많다.
	// 알고리즘 - 나중에 배울 길찾기 알고리즘에 쓰이는 자료구조

	// ★★★★★ 무조건 외워야 할 규칙
	// 규칙 1 : 무조건 높이가 균일해야 한다.
	// 규칙 2 : 무조건 왼쪽노드부터 하나씩 채워가야한다.
	// 규칙 3 : 무조건 부모노드는 자식노드보다 커야한다.

	// 특징 1 : i번째 노드의 부모 인덱스 : (i - 1) / 2 
	// 특징 2 : Root는 항상 가장 큰 값이다.
	// 다음 나올값을 확인하는 Peek()의 기대값 => O(1)

	// 우선순위 큐에 데이터를 쌓을 때 -> 시간복잡도 O(logN)
	// 1. 새로운 노드의 값이 부모보다 크다면 부모와 값을 바꿔준다. -> 도장깨기 하듯이 계속 이어간다.(부모노드와 조부모노드를 비교... 쭈욱)
	
	// 우선순위 큐에서 데이터를 뺄 때 -> 시간복잡도 O(logN)
	// 1. 없앤 노드의 자리에 가장 마지막(꼬리쪽) 노드를 넣고 그 자리의 자식 노드들 중 큰 값과 비교해서 작으면 교체해준다. (이것도 쭈욱 반복)

	// 우선순위 큐에 다음 데이터 확인 Peek() -> 시간복잡도 O(1)

}