
void summary()
{
	// 1. 숙제 체크 / 구현
	// 2. 디자인패턴 - 더블 버퍼링 (설명 및 구현)
	// 3. 프레임워크 (설명하고 계속 진행)
}


void Comment1()
{
	// Windows API 특징

	// Windows API 와 콘솔의 가장 큰 차이 (체감상)
	// - Render ( 그리는 부분 )
	// - Upadate ( 로직 )
	// 이 구분되어있다.

	// 게임엔진을 다뤄본적이 있다면 별 거부감이 없을테지만
	// 처음하신 분들은 큰 영향을 받는다.

	// Updata => 변수들이 뭔가 변한다.
	// Render => 그 변수들로 인하여, 그리는 내용을 어떻게 그릴것인지 정해준다.

	// 더블 버퍼링 : 깜빡거림 발생할 떄 화면을 두개로 두고 
	// Windows API에서 그리고 있는데 마우스 이동이나 키보드 입력으로 인해 WM_PAINT를 다시 실행시켜서 
	// 다 지우고 다시 그리라고 명려하게 된다.
	// 그 과정에서 깜빡거림이 발생한다.

	// 이걸 해결하고자 만드는 게 화면을 두개로 두고 한쪽에 변경을 하고 한쪽에 그 화면을 복사하는것
	// 이걸 일 초에 몇번 하느냐에 따라 FPS가 달라진다.
	// FPS : Frame Per Seconds

	// 프레임워크
	
	// 엔진 : 제품을 만들기 위해 만들어진 툴 (게임엔진 안에 프레임워크는 무조건 포함되어 있다.)
	// 프레임워크 : 프로그램을 잘 만들기 위해 만들어둔 아키텍처 코드 뭉치 (아키텍처 : 프로그램 구조 (클래스 설계))
	// 라이브러리 : 특정 기능만 포함한 코드뭉치
	// - 카메라 라이브러리, 이미지 프로세싱 라이브러리, 통신 라이브러리 등
	
	// 규모 
	// 라이브러리 < 프레임워크 < 엔진

	// 엔진은 프로그래머 말고 아트랑 기획이 사용할 수 있어야 함

	// 라이브러리와 프레임워크의 차이는
	// 이걸 쓰기 위해서
	// 프레임워크에 내 코드를 맞춘다.
	// 내 코드에 라이브러리를 맞춘다.

	// Windows API를 하는데 왜 프레임워크를 만들면서 해야하는가?

	// 회사에선 Windows API는 절대 안쓴다.
	// 근데 왜 배우는가?
	// 엔진에 들어간 기술을 배우기 위해서!!

	// Windows API를 효과적으로 배우기 위해서는
	// 엔진에서 쓰이는 기술을 그대로 만들 수 있어야 한다.

	// 지금 Windows API 하는 과정은
	// 게임 엔진을 만들어보는 과정이랑 아주 흡사하다.(근데 그냥 맛보기 수준)

	// DirectX도 하긴 할건데 맛보기 과정이다.(주로 이론 위주)
	// DX는 Windows API 하다가 한계점이 봉착하면 조금 나갈 정도로 할거다.
	// 선생님 생각은 DX의 기본적 내용 외에는 그닥 중요하지 않다 하신다.

	// 게임엔진 원리의 이해를 위해 하는 수업이다. 
	// 돌아가는 원리는 두 번 다시 설명 안한다 하신다. ㄴ
}