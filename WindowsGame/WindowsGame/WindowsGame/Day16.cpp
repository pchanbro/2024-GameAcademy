#include "framework.h"
#include "WindowsGame.h"

// 이름 별칭문법 typedef
// typedef A B
// A를 B라고 칭한다
typedef int 인트;

// 여기서 중요한건 HINSTANCE, HWND

// HINSTANCE(인스턴스 핸들) : 인스턴스 자료구조
// 인스턴스란?
//      작업관리자 켰을 때 나오는거

// ATOM : unsigned short

// BOOL : int

// LRESULT : __int64

// HWND(윈도우 핸들) : 작업관리자 세부 

// UINT : unsigned int

// WPARAM : unsigned __int64

// LPARAM : __int64

// LPWSTR : wchar_t*



// 중요!!

// wchar 와 char의 차이

// char : 아스키코드(멀티바이트)
// wchar : 유니코드

// 아스키코드 : 문자를 적으면 => 숫자로 변환해주는 코드 
// 아스키코드의 문제 
//      - 영어가 아닌 다른 언어는 표시할 수 없다.

// 아스키코드 (1바이트) (멀티바이트)
// 0 ~ 127
// 
// 
// 멀티바이트
// - 1바이트로 표현할 수 있는건 1바이트로 표현하고,
// - 안되면 2바이트 넘게 쓰는 것
// 
// 
// 유니코드 (2바이트) (UTF-16)
// 모든 문자를 같은 바이트로 표기할 수 있게 하자. (최소 2바이트)
// Visual Studio 기준, UTF-16이라는 것을 사용.
// 2바이트로 표시하면 모든 문자를 다 표시할 수 있지 않을까라는 생각에서 시작한 것이 유니코드
// UTF-16, UTF-32 등등 

// 원래는 영어 외에 다른 언어를 표기하지 못했다.
// 멀티바이트, 아스키코드밖에 없었기 때문이다.
// 아스키코드의 개념이 확장되면서, 
// 1바이트가 아닌, 여러바이트(멀티바이트)로 문자열을 표기할 수 있게 하자.
// 멀티바이트로 만들어진 프로그램이 굉장히 많아짐 (가장 유명한 것이 UTF-8)

// 유니코드는 그럼 왜 생겼나??
// 멀티바이트로 하니까 서버통신이나 그와 관련된 부분들이 엄청 복잡해짐
// 나라마다 읽어야 하는 언어가 다름
// 궭뷁 << 이런 말
// 이게 멀티바이트를 여러가지로 변환하다보니 생긴 문제
// 유니코드 << 이거로 모든 문자를 아스키코드처럼 정해두자.
// 세계표준으로 나온 코드들이다.
// 근데 누가 세계 표준을 정하냐?
// 정하는 사람이 없어서 유니코드 종류가 매우 많다.
// UTF-16, UTF-32, CP949 등등 있는데 우리는 이 3가지만 알자


// C, C++ 같은경우에는 함수 하나당 return값 한개밖에 못받는다.
// 함수에 매개변수로 리턴을 받을 수 있는 매개변수를 따로 주는 형식으로 채택
// c 형식에서 Return값을 함수의 성공유무로 많이 사용한다.  

// _In_     => 매개변수를 주입만하고, 리턴값으로 사용하지 않는다.
// _Out_    => 매개변수를 리턴값으로 사용한다.
// _In_Out_ => 매개변수를 주입도 하고 리턴값으로도 사용한다.
// _In_Opt_ => 매개변수가 필수사항은 아니다. 일단 주입될 수 있도록 구상했다.

//#include <string>
//using namespace std;
//
//
//void Day16()
//{
//    인트 a = 0;
//
//    char c = 'a';
//
//    //아스키코드에 의해 printf("%d", a); 하면 97 나옴
//
//    // 멀티바이트 
//    string myStr = "my string"; // m적을때 1바이트만 들어감
//
//    // 유니코드
//    wstring myWString = L"My String"; // 앞에 L을 적음으로써 유니코드 작성 가능 // m 적을때 2바이트 들어감
//    wchar_t myWChar[128] = L"asdf";
//
//    // 멀티바이트와 유니코드를 둘 다 지원하기 위해서 만들어진 문자 자료형
//    TCHAR tChar[128];
//
//    // L 대신에 _T를 적어도 된다.
//    // _T는 속성이 멀티바이트로 되어있으면 멀티바이트로 적용하고
//    // 유니코드로 되어있으면 유니코드로 적용한다.
//    wstring myWString = _T("My String");
//
//    // 우리 프로젝트는 최대한 _T를 사용하되, 기본적으로 유니코드를 사용
//}
//
