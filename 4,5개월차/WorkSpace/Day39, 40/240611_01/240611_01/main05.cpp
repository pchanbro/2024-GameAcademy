#include <iostream>

using namespace std;

void main()
{
	// 길찾기 알고리즘
	// 다익스트라보다 더 좋은게 없을거 같은데?
	// BFS 만큼 깔끔하게 길찾는 방법이 없을줄알았는데 (간선의 비용이 다른경우 문제가 생김)
	// 간선에 비용을 추가해서 더 효율적인 길을 찾는 Dijikstra 로직이 만들어짐. 
	//	( 원하는건 end 포인트로 가는 길찾기인데 뭔가 효율적이지 않음 )
	// Dijikstra는 자기 중심으로 퍼져가면서 길을 찾기 때문에 비효율 발생
	// 
	// dijikstra 를 조금 변형해서
	
	// astar 알고리즘

	// 비용계산을 조금 다르게합니다.
	// queue에 넣을때
	// 다익스트라 같은 경우 -> G [내 현재까지 온 비용 + 목표까지 가는 비용]
	// astar 경우 -> G [내 현재까지 온 비용 + 목표까지 가는 비용] + H (현재 좌표부터 목표까지 가는 예상 기댓값)

	// 처음부터 astar에 대해 알려주지 않은 이유
	// 1. 우선 순위 큐에 대해 알아야하고
	// 2. DFS, BFS에 대해 알아야하고
	// 3. BFS -> 다익스트라로 변형하는 과정
	// 4. 다익스트라 -> 에이스타로 변형하는 과정

	// 이 과정들을 알아야 astar를 알 수 있기 때문이다.

}

//숙제 2개

// 1. 콘솔에서 Astar로 미로 길찾기 (BFS랑 길이 달라지진 않습니다.)
// 2. Windows API에서 BFS나, Astar 사용해서 타일 클릭하면 플레이어가 해당 타일로 이동하는 로직 만들기



// 아래의 로직이 만들어지는 과정, 그 흐름을 이해하고 외워라


// 길찾기 알고리즘 -> 결국엔 (Astar, A*) 이거를 배우기 위함이다

// 길찾기 알고리즘
// 가장 보편화되어있는 알고리즘
// => DFS, BFS
//  => 그래프 자료구조
//   => (정점, 간선)으로 이루어진 자료구조

// DFS, BFS 공통점
// => 어떻게 해야 A정점에서 ?정점을 갈 수 있는지? 에 대한 답을 얻을 수 있었다.

// DFS, BFS 차이점
//  DFS => 깊이 탐색 알고리즘으로, stack을 통해서
//			하나의 정점을 선택했으면, 
//			 그 정점에서 더 이상 갈 수 없는 지점까지 먼저 탐색
// 이거 워딩을 외우기보다는 stack이라는 키워드를 통해 머리속에 그림을 그려서 설명할 줄 알면 됨

// BFS => 넓이 탐색 알고리즘으로, queue를 통해서
//			갈 수 있는 정점들을 depth가 같아지는 선에서 점점 넓혀감
//			 "최대한 빨리" 알고리즘


// DFS, BFS => 특정 정점에서 ?정점까지 갈 수 있냐 없냐를 판단.
// 근데 이거 문제가 있음
// ex) A->D노드를 가는데, 사실은
// A->C->D 가 제일 빠른데
// A->E->B->D 이 길을 알려주게 될 수 있다.
// 왜냐면 DFS, BFS는 비용은 체크안하고 단순하게 갈 수 있냐, 없냐만 체크하기 때문


// 다익스트라 (dijikstra) 알고리즘 (사람 이름을 딴 알고리즘)
//  간선에 비용을 추가시켜서 
//  BFS로직을 적용
//  "최대한 빨리" 각 정점을 지나는 방법을 탐색하는 알고리즘
//  BFS (queue => priority_queue 로 수정)

//   문제가 발생
//  단순하게 직선 방향으로 탐색하면 금방 찾을것 같은 목적지인데
//  모든 경우의 수를 계산하려고 한다.
//   => 느려진다.


// Astar => 목적지가 있는 경우에 최적의 길찾기를 계산
//  (queue => priority_queue 로 수정)
//  priority_queue 넣는 비용을
//  다익스트라 => 처음 위치에서 해당 위치로 가는데 드는 비용 (G)
//  에이스타 => 처음 위치에서 해당 위치로 가는데 드는 비용 (G) + 해당 위치에서 목적지까지 가는데 드는 예상 비용 (H)

// F = G + H




// 지금까지 했던거
// 자료구조, 알고리즘 ( 코테, 면접)
// - linked_list, vector, BinaryTree
// - map
// - queue, stack
// - priority_queue

// 알고리즘
//  - BinarySearch
//  - DFS, BFS, dijikstra, astar